(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{359:function(t,_,a){t.exports=a.p+"assets/img/data3.b6b71ec4.jpg"},360:function(t,_,a){t.exports=a.p+"assets/img/data4.6ebf4264.jpg"},361:function(t,_,a){t.exports=a.p+"assets/img/data5.98df8e70.jpg"},362:function(t,_,a){t.exports=a.p+"assets/img/data6.3f70b4ad.jpg"},363:function(t,_,a){t.exports=a.p+"assets/img/data7.b69b8c5d.jpg"},375:function(t,_,a){"use strict";a.r(_);var v=a(43),e=Object(v.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"数组"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[t._v("#")]),t._v(" 数组")]),t._v(" "),v("blockquote",[v("p",[t._v("几乎所有的编程语言都原生支持数组类型，因为数组是最简单的内存数据结构")])]),t._v(" "),v("h2",{attrs:{id:"什么是数组"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是数组"}},[t._v("#")]),t._v(" 什么是数组")]),t._v(" "),v("p",[v("strong",[t._v("数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。")])]),t._v(" "),v("p",[t._v("这个定义有几个关键字我们分别来理解一下。")]),t._v(" "),v("h3",{attrs:{id:"线性表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#线性表"}},[t._v("#")]),t._v(" 线性表")]),t._v(" "),v("p",[v("strong",[t._v("线性表")]),t._v("就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。")]),t._v(" "),v("p",[v("img",{attrs:{src:a(359),alt:"data3"}})]),t._v(" "),v("p",[v("strong",[t._v("非线性表")]),t._v("，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。")]),t._v(" "),v("p",[v("img",{attrs:{src:a(360),alt:"data4"}})]),t._v(" "),v("h3",{attrs:{id:"连续的内存空间和相同类型的数据"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#连续的内存空间和相同类型的数据"}},[t._v("#")]),t._v(" 连续的内存空间和相同类型的数据")]),t._v(" "),v("p",[t._v("正是因为这两个限制，数组才具有"),v("strong",[t._v("随机访问")]),t._v("的特性。但有利就有弊，这两个限制也让数组的很多操作变得非常低效，比如要想在数组中"),v("strong",[t._v("删除、插入一个数据")]),t._v("，为了保证连续性，就需要做大量的数据迁移。")]),t._v(" "),v("h2",{attrs:{id:"随机访问"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#随机访问"}},[t._v("#")]),t._v(" 随机访问")]),t._v(" "),v("p",[t._v("数组是如何实现根据下标随机访问数组元素。")]),t._v(" "),v("p",[t._v("一个长度为 10 的 "),v("code",[t._v("int")]),t._v(" 类型的数组 "),v("code",[t._v("int[] a = new int[10]")]),t._v("来举例。在这个图中，计算机给数组 "),v("code",[t._v("a[10]")]),t._v("，分配了一块连续内存空间 1000～1039，其中，内存块的首地址为 "),v("code",[t._v("base_address = 1000")]),t._v("。")]),t._v(" "),v("p",[v("img",{attrs:{src:a(361),alt:"data5"}})]),t._v(" "),v("p",[t._v("计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：")]),t._v(" "),v("div",{staticClass:"language-java line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-java"}},[v("code",[v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//其中 data_type_size 表示数组中每个元素的大小")]),t._v("\na"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("_address "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" base_address "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" i "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" data_type_size \n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br")])]),v("p",[t._v("数组支持随机访问，根据下标随机访问的时间复杂度为 "),v("code",[t._v("O(1)")]),t._v("。")]),t._v(" "),v("h2",{attrs:{id:"数组的插入和删除操作"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数组的插入和删除操作"}},[t._v("#")]),t._v(" 数组的插入和删除操作")]),t._v(" "),v("h4",{attrs:{id:"插入操作"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#插入操作"}},[t._v("#")]),t._v(" 插入操作")]),t._v(" "),v("p",[t._v("假设数组的长度为 "),v("code",[t._v("n")]),t._v("，现在，如果我们需要将一个数据插入到数组中的第 "),v("code",[t._v("k")]),t._v(" 个位置。为了把第 "),v("code",[t._v("k")]),t._v(" 个位置腾出来，给新来的数据，\n我们需要将第 "),v("code",[t._v("k～n")]),t._v(" 这部分的元素都顺序地往后挪一位。那插入操作的时间复杂度是多少呢？你可以自己先试着分析一下。")]),t._v(" "),v("p",[t._v("如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为 "),v("code",[t._v("O(1)")]),t._v("。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是 "),v("code",[t._v("O(n)")]),t._v("。\n因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 "),v("code",[t._v("(1+2+…n)/n=O(n)")]),t._v("。")]),t._v(" "),v("p",[t._v("如果数组中的数据是有序的，我们在某个位置插入一个新的元素时，就必须按照刚才的方法搬移 "),v("code",[t._v("k")]),t._v(" 之后的数据。但是，如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。\n在这种情况下，如果要将某个数据插入到第 "),v("code",[t._v("k")]),t._v(" 个位置，为了避免大规模的数据迁移，我们还有一个简单的办法就是，直接将第 "),v("code",[t._v("k")]),t._v(" 位的数据迁移到数组元素的最后，把新的元素直接放入第 "),v("code",[t._v("k")]),t._v(" 个位置。")]),t._v(" "),v("p",[t._v("为了更好地理解，我们举一个例子。假设数组 "),v("code",[t._v("a[10]")]),t._v("中存储了如下 5 个元素："),v("code",[t._v("a，b，c，d，e")]),t._v("。")]),t._v(" "),v("p",[t._v("我们现在需要将元素 "),v("code",[t._v("x")]),t._v(" 插入到第 3 个位置。我们只需要将 "),v("code",[t._v("c")]),t._v(" 放入到 "),v("code",[t._v("a[5]")]),t._v("，将 "),v("code",[t._v("a[2]")]),t._v("赋值为 "),v("code",[t._v("x")]),t._v(" 即可。最后，数组中的元素如下： "),v("code",[t._v("a，b，x，d，e，c")]),t._v("。")]),t._v(" "),v("p",[v("img",{attrs:{src:a(362),alt:"data6"}})]),t._v(" "),v("p",[t._v("利用这种处理技巧，在特定场景下，在第 "),v("code",[t._v("k")]),t._v(" 个位置插入一个元素的时间复杂度就会降为 "),v("code",[t._v("O(1)")]),t._v("。")]),t._v(" "),v("h4",{attrs:{id:"删除操作"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#删除操作"}},[t._v("#")]),t._v(" 删除操作")]),t._v(" "),v("p",[t._v("跟插入数据类似，如果我们要删除第 "),v("code",[t._v("k")]),t._v(" 个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为 "),v("code",[t._v("O(1)")]),t._v("；\n如果删除开头的数据，则最坏情况时间复杂度为 "),v("code",[t._v("O(n)")]),t._v("；平均情况时间复杂度也为"),v("code",[t._v("O(n)")]),t._v("。\n实际上，在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，删除的效率是不是会提高很多呢？我们继续来看例子。\n数组 "),v("code",[t._v("a[10]")]),t._v("中存储了 8 个元素："),v("code",[t._v("a，b，c，d，e，f，g，h")]),t._v("。现在，我们要依次删除 "),v("code",[t._v("a，b，c")]),t._v(" 三个元素。")]),t._v(" "),v("p",[v("img",{attrs:{src:a(363),alt:"data7"}})]),t._v(" "),v("p",[t._v("为了避免 "),v("code",[t._v("d，e，f，g，h")]),t._v(" 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。\n每次的删除操作并不是真正地迁移数据，只是记录数据已经被删除。\n当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据迁移。")]),t._v(" "),v("h2",{attrs:{id:"数组操作常用方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数组操作常用方法"}},[t._v("#")]),t._v(" 数组操作常用方法")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("操作")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("方法")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("尾部插入元素")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("push")])]),t._v(" "),v("tr",[v("td",[t._v("头部插入元素")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("unshift")])]),t._v(" "),v("tr",[v("td",[t._v("尾部删除元素")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("pop")])]),t._v(" "),v("tr",[v("td",[t._v("头部删除元素")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("shift")])]),t._v(" "),v("tr",[v("td",[t._v("在任意位置添加或删除元素")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("splice")])])])])])}),[],!1,null,null,null);_.default=e.exports}}]);